// Generated by CoffeeScript 1.6.3
/*

	A waveform object provides an API for rendering a data array or MP3 url onto a canvas. The object is initialized 
	with a <div> element that will contain the canvas on which the waveform will be rendered. Once specified, the 
	object will also provide hooks for changing the zoom level and offset of the visible portion - the idea is that a 
	user could use this as a foundational element for an audio editor or instrument, such as a sampler.
*/

var Waveform;

Waveform = (function() {
  function Waveform(_container) {
    var canvasContainer;
    this._container = _container;
    canvasContainer = document.createElement("div");
    canvasContainer.setAttribute("id", "canvas-container");
    this._container.appendChild(canvasContainer);
    this._canvas = document.createElement("canvas");
    this._canvas.width = this._container.clientWidth - this.CONTROL_SIZE - 1;
    this._canvas.height = this._container.clientHeight - this.CONTROL_SIZE;
    canvasContainer.appendChild(this._canvas);
    this._container.appendChild(this._controls());
    this._container.style["margin-top"] = "" + (document.body.clientHeight / 2) + "px";
    this._container.style["top"] = "-" + (this._container.clientHeight / 2) + "px";
  }

  Waveform.prototype._data = [];

  Waveform.prototype._zoom = 1.0;

  Waveform.prototype._start = 0.0;

  Waveform.prototype._image = null;

  Waveform.prototype.X_SCALE = 0.05;

  Waveform.prototype.Y_SCALE = 0.8;

  Waveform.prototype.DOWNSAMPLE_TARGET = 100000;

  Waveform.prototype.CONTROL_SIZE = 20;

  Waveform.prototype._controls = function() {
    var box, controls, id, text, _i, _len, _ref, _ref1;
    controls = document.createElement("div");
    controls.setAttribute("id", "control-container");
    _ref = [["ctrl-in", "+"], ["ctrl-out", "&mdash;"], ["ctrl-left", "&larr;"], ["ctrl-right", "&rarr;"]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], id = _ref1[0], text = _ref1[1];
      box = document.createElement("div");
      box.setAttribute("id", id);
      box.setAttribute("class", "ctrl-box");
      box.innerHTML = text;
      controls.appendChild(box);
    }
    return this._controls = controls;
  };

  Waveform.prototype._audio = new webkitAudioContext();

  Waveform.prototype.waveformFromMP3URL = function(url, cb) {
    var xhr,
      _this = this;
    if (cb == null) {
      cb = (function() {});
    }
    xhr = new XMLHttpRequest();
    xhr.responseType = "arraybuffer";
    xhr.open("GET", url);
    xhr.addEventListener("readystatechange", function() {
      if (4 === xhr.readyState) {
        return _this._audio.decodeAudioData(xhr.response, function(aud) {
          var downsample;
          downsample = Math.ceil(aud.getChannelData(0).length / _this.DOWNSAMPLE_TARGET);
          // Writing this in javascript since coffeescript makes it annoying
				  var max = Number.MIN_VALUE; // for normalization
					var buf = new Float32Array(aud.length / downsample)
					for(var bin = 0, len1 = buf.length; bin < len1; ++bin) {
						var avg = 0.0;
						for(var chan = 0, len3 = aud.numberOfChannels; chan < len3; ++chan) {
							var chanData = aud.getChannelData(chan);
							for(var idx = bin * downsample, len2 = idx + downsample; idx < len2; ++idx) {
								avg += chanData[idx];
							}
						}
						avg /= (aud.numberOfChannels * downsample);
						buf[bin] = avg;
						max = Math.max(avg, max);
					}

					for(bin = 0; bin < len1; ++bin) {
						buf[bin] = buf[bin] / max;
					}

					_this.waveformFromArray(buf, cb);
        });
      }
    });
    return xhr.send();
  };

  Waveform.prototype.waveformFromArray = function(buf, cb) {
    if (cb == null) {
      cb = (function() {});
    }
    this._zoom = 1;
    this._start = 0.0;
    this._data = buf;
    this._initSelected();
    return this._render(cb);
  };

  Waveform.prototype.zoom = function(zoom) {
    if (zoom !== this._zoom) {
      this._zoom = zoom;
      return this._render();
    }
  };

  Waveform.prototype.zoomIn = function() {
    var zoom;
    zoom = Math.max(10 / this._length(), this._zoom * this.Y_SCALE);
    if (this._zoom !== zoom) {
      this._zoom = zoom;
      return this._render();
    }
  };

  Waveform.prototype.zoomOut = function() {
    var zoom;
    zoom = Math.min(1.0, this._zoom / this.Y_SCALE);
    if (this._zoom !== zoom) {
      this._zoom = zoom;
      this._start = this._correctStart(this._start);
      return this._render();
    }
  };

  Waveform.prototype._panDiff = function() {
    var dataEnd, dataLength, dataStart;
    dataLength = Math.ceil(this._length() * this._zoom);
    dataStart = Math.floor(this._length() * this._start);
    dataEnd = Math.min(this._length() - 1, dataStart + dataLength);
    return this.X_SCALE * (dataEnd - dataStart) / this._length();
  };

  Waveform.prototype._correctStart = function(start) {
    var length, overflow;
    length = this._length() * this._zoom;
    start = this._length() * start;
    overflow = start + (length - this._length());
    if (overflow > 0.0) {
      return (this._length() - length) / this._length();
    } else {
      return start / this._length();
    }
  };

  Waveform.prototype.pan = function(val) {
    var start;
    start = Math.max(0.0, Math.min(1.0 - this._panDiff(), this._correctStart(val)));
    if (start !== this._start) {
      this._start = start;
      return this._render();
    }
  };

  Waveform.prototype.panRight = function() {
    var start;
    start = Math.min(1.0 - this._panDiff(), this._correctStart(this._start + this._panDiff()));
    if (start !== this._start) {
      this._start = start;
      return this._render();
    }
  };

  Waveform.prototype.panLeft = function() {
    var start;
    start = Math.max(0.0, this._correctStart(this._start - this._panDiff()));
    if (start !== this._start) {
      this._start = start;
      return this._render();
    }
  };

  Waveform.prototype._render = function(cb, iteratorName) {
    var dataEnd, dataStart, it, _dataLength;
    if (cb == null) {
      cb = (function() {});
    }
    if (iteratorName == null) {
      iteratorName = "renderIterator";
    }
    _dataLength = Math.ceil(this._length() * this._zoom);
    dataStart = Math.floor(this._length() * this._start);
    dataEnd = Math.min(this._length() - 1, dataStart + _dataLength);
    it = this["_" + iteratorName](dataStart, dataEnd);
    it.open();
    while (it.hasNext()) {
      it.next();
    }
    it.close();
    this._renderSelected();
    return cb();
  };

  Waveform.prototype._initSelected = function() {
    var canvas, selected, swap;
    selected = document.getElementById("selected-container");
    canvas = document.createElement("canvas");
    selected.appendChild(canvas);
    canvas.width = selected.clientWidth;
    canvas.height = selected.clientHeight;
    swap = this._canvas;
    this._canvas = canvas;
    this._render();
    return this._canvas = swap;
  };

  Waveform.prototype._renderSelected = function() {
    var offset, selected, width;
    selected = document.getElementById("selected-bar");
    width = this._zoom * 100;
    offset = (this._width() + this.CONTROL_SIZE + 1) * this._start;
    selected.style["width"] = "" + width + "%";
    return selected.style["left"] = "" + offset + "px";
  };

  Waveform.prototype._renderIteratorHighRes = function(dataStart, dataEnd) {
    var context, data, height, index, length, stepSize, xCoord, xNext, yCoord, yNext,
      _this = this;
    console.log("Zoom " + this._zoom + " and Start " + this._start);
    data = this._data.subarray(dataStart, dataEnd + 1);
    length = data.length;
    stepSize = this._width() / (dataEnd - dataStart);
    height = this._height();
    xCoord = function(idx) {
      return stepSize * idx;
    };
    xNext = function(idx) {
      return xCoord(idx + 1);
    };
    yCoord = function(idx) {
      return (((0.95 * data[idx]) + 1.0) / 2.0) * height;
    };
    yNext = function(idx) {
      return yCoord(idx + 1);
    };
    console.log("Length " + length + " and Step " + stepSize);
    index = 0;
    context = this._canvas.getContext("2d");
    context.fillStyle = "#FFF";
    context.fillRect(0, 0, this._width(), this._height());
    return {
      open: function() {
        context.beginPath();
        return context.moveTo(xCoord(index), yCoord(index));
      },
      close: function() {
        while (yCoord(index) < _this._width()) {
          this.next();
        }
        return context.stroke();
      },
      hasNext: function() {
        return index < (length - 1);
      },
      next: function() {
        var xc, yc;
        xc = (xCoord(index) + xNext(index)) / 2;
        yc = (yCoord(index) + yCoord(index)) / 2;
        context.quadraticCurveTo(xCoord(index), yCoord(index), xc, yc);
        return ++index;
      }
    };
  };

  Waveform.prototype._renderIterator = Waveform.prototype._renderIteratorHighRes;

  Waveform.prototype._length = function() {
    return this._data.length;
  };

  Waveform.prototype._width = function() {
    return this._canvas.width;
  };

  Waveform.prototype._height = function() {
    return this._canvas.height;
  };

  return Waveform;

})();
